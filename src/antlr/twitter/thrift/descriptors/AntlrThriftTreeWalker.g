// =================================================================================================
// Copyright 2011 Twitter, Inc.
// -------------------------------------------------------------------------------------------------
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this work except in compliance with the License.
// You may obtain a copy of the License in the LICENSE file, or at:
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// =================================================================================================

// Generates a parser that parses the AST generated by Thrift.g and creates
// descriptors for the underlying thrift file. The generated parser returns
// an instance of the Program thrift struct.
//
// There are grammar elements (such as senum, xsdAttributes, cppType) that are not reflected
// in the descriptors. We allow those to be present in the input, but don't act on them.

// Note the naming conventions: Grammar rules and thrift descriptor fields are camelCase,
// python variables in the generated code are words_with_underscores_.

// Note that many of the names of entities here are reserved words in various languages,
// and sometimes in ANTLR itself (e.g., 'type', 'namespace', 'include' and so on). This is
// a known hazard when writing reflection frameworks. To avoid collisions, we make frequent
// use of trailing underscores in variable names.

// Author: Benjy Weinberger

tree grammar AntlrThriftTreeWalker;

options {
  language = Python;
  tokenVocab = AntlrThrift;
  ASTLabelType = CommonTree;
}

@header {
  from gen.twitter.thrift.descriptors import ttypes as thrift_descriptors
  from twitter.thrift.descriptors.thrift_parser_error import ThriftParserError

  _global_type_id = -1
}

@init {
  self._program = thrift_descriptors.Program()
  self._program.typeRegistry = thrift_descriptors.TypeRegistry()
  self._program.typeRegistry.idToType = {}
  self._program.typeRegistry.aliasToTypeId = {}
  self._type_id_generator = self._create_type_id_generator()
}

@members {
  def _append(self, list_name, element):
    list = getattr(self._program, list_name)
    if list is None:
      list = []
      setattr(self._program, list_name, list)
    list.append(element)

  def _create_type_id_generator(self):
    global _global_type_id
    while True:
      _global_type_id += 1
      yield 'T' + str(_global_type_id)

  def _registerType(self, location, typ):
    typ.id = self._type_id_generator.next()
    if typ.id in self._program.typeRegistry.idToType:
      raise self._error(location, 'Type id already exists: ' + typ.id)  # Should never happen.
    self._program.typeRegistry.idToType[typ.id] = typ

  def _registerTypedef(self, location, typedef):
    if typedef.typeAlias in self._program.typeRegistry.aliasToTypeId:
      raise self._error(location, 'Type alias already exists: ' + typedef.typeAlias)
    self._program.typeRegistry.aliasToTypeId[typedef.typeAlias] = typedef.typeId

  def _error(self, location, msg):
    return ThriftParserError('line ' + str(location.line) + ', col ' +
                             str(location.charPositionInLine) + ': '+ msg)
}

program returns [program_]
@after {
  program_ =  self._program
}
  : ^(PROGRAM header* definition*);

header
@init {
  def add_namespace(self, language, name):
    namespace_ = thrift_descriptors.Namespace()
    namespace_.language = language
    namespace_.name = name
    self._append('namespaces', namespace_)
}
  : ^(INCLUDE LITERAL) {
      include_ = thrift_descriptors.Include()
      include_.path = $LITERAL.text[1:-1]
      self._append('includes', include_)
    }
  | ^(NAMESPACE language_=namespaceLanguage name_=namespaceName) {
      add_namespace(self, language_, $name_.text)
    }
  ;

namespaceLanguage returns [language_]
  : IDENTIFIER { language_ = $IDENTIFIER.text }
  | STAR { language_ = '*' }
  ;

namespaceName:
  IDENTIFIER | ST_IDENTIFIER | LITERAL;  // Various of these are allowed for various languages.

definition:
  const |
  typeDefinition |
  service;

const
  : ^(CONST type_=fieldType IDENTIFIER const_value_=constValue) {
      const_ = thrift_descriptors.Const()
      const_.typeId = type_.id
      const_.name = $IDENTIFIER.text
      const_.value = $const_value_.text
      self._append('constants', const_)
    }
  ;

constValue:
  intConstant |
  DUBCONSTANT |
  LITERAL |
  IDENTIFIER |
  constList |
  constMap;

constList:
  ^(CONST_LIST constValue*);

constMap:
  ^(CONST_MAP constValuePair*);

constValuePair:
  ^(PAIR k=constValue v=constValue);

typeDefinition:
  typedef |
  enum |
  struct |
  union |
  xception;

typedef
  : ^(TYPEDEF type_=fieldType IDENTIFIER annotations_=typeAnnotations) {
      typedef_ = thrift_descriptors.Typedef()
      typedef_.typeId = type_.id
      typedef_.typeAlias = $IDENTIFIER.text
      if annotations_ is not None:
        typedef_.annotations = annotations_
      self._append('typedefs', typedef_)
      self._registerTypedef($IDENTIFIER, typedef_)
    }
  ;

enum
scope {
  // We gather the enum elements in these variables in the parent enum scope.
  elements;
  last_value;
}
@init {
  $enum::elements = []
  $enum::last_value = -1
}
  : ^(ENUM IDENTIFIER enumDef* annotations_=typeAnnotations) {
      enum_ = thrift_descriptors.Enum()
      enum_.name = $IDENTIFIER.text
      enum_.elements = $enum::elements
      if annotations_ is not None:
        enum_.annotations = annotations_
      self._append('enums', enum_)
    }
  ;

enumDef
@init {
  def add_enum_element(location, name, value=None, annotations=None):
    if value is None:
      value = $enum::last_value + 1
    elif value <= $enum::last_value:
      raise self._error(location, 'Enum value for ' + name + ' must be >= ' +
                                  str($enum::last_value + 1) + ': ' + str(value))
    if value >= 2**31:
      raise self._error(location, 'Enum value for ' + name + ' must be < 2^31: ' + str(value))
    enum_element_ = thrift_descriptors.EnumElement()
    enum_element_.name = name
    enum_element_.value = value
    enum_element_.annotations=annotations
    $enum::elements.append(enum_element_)
    $enum::last_value = value
}
  : ^(ENUM_DEF IDENTIFIER int_constant_=intConstant annotations_=typeAnnotations) {
      add_enum_element($IDENTIFIER, $IDENTIFIER.text, int_constant_, annotations_)
    }
  | ^(ENUM_DEF IDENTIFIER annotations_=typeAnnotations) {
      add_enum_element($IDENTIFIER, $IDENTIFIER.text, annotations=annotations_)
    }
  ;

struct
  : ^(STRUCT IDENTIFIER XSD_ALL? fields_=fields annotations_=typeAnnotations) {
      struct_ = thrift_descriptors.Struct()
      struct_.name = $IDENTIFIER.text
      struct_.fields = fields_
      if annotations_ is not None:
        struct_.annotations = annotations_
      self._append('structs', struct_)
    }
  ;

union
  : ^(UNION IDENTIFIER XSD_ALL? fields_=fields annotations_=typeAnnotations) {
      union_ = thrift_descriptors.Union()
      union_.name = $IDENTIFIER.text
      union_.fields = fields_
      if annotations_ is not None:
        union_.annotations = annotations_
      self._append('unions', union_)
    }
  ;

xception
  : ^(EXCEPTION IDENTIFIER fields_=fields annotations_=typeAnnotations) {
      exception_ = thrift_descriptors.Exception()
      exception_.name = $IDENTIFIER.text
      exception_.fields = fields_
      if annotations_ is not None:
        exception_.annotations = annotations_
      self._append('exceptions', exception_)
    }
  ;

service
scope {
  // We gather the functions in this variable in the parent service scope.
  function_list;

  // The set of function names we've already used. Used for validation.
  used_function_names;
}
@init {
  $service::function_list = []
  $service::used_function_names = set()
}
  : ^(SERVICE IDENTIFIER extendz_=extendz? function* annotations_=typeAnnotations) {
      service_ = thrift_descriptors.Service()
      service_.name = $IDENTIFIER.text
      if extendz_ is not None:
        service_.extendz = extendz_
      service_.functions = $service::function_list
      if annotations_ is not None:
        service_.annotations = annotations_
      self._append('services', service_)
    }
  ;

extendz returns [extendz_]:
  ^(EXTENDS IDENTIFIER) { extendz_ = $IDENTIFIER.text };

function returns [function_]
  : ^(FUNCTION oneway_=ONEWAY? return_type_=functionType IDENTIFIER argz_=fields throwz_=throwz? annotations_=typeAnnotations) {
      function_name_ = $IDENTIFIER.text
      if function_name_ in $service::used_function_names:
        raise self._error($IDENTIFIER, 'Function name ' + function_name_ + ' already used in this service')
      function_ = thrift_descriptors.Function()
      function_.name = function_name_
      if return_type_ is None:
        function_.returnTypeId = None
      else:
        function_.returnTypeId = return_type_.id
      if oneway_ is not None:
        function_.oneWay = True
      function_.argz = argz_
      if throwz_ is not None:
        function_.throwz = throwz_
      if annotations_ is not None:
        function_.annotations = annotations_
      $service::function_list.append(function_)
      $service::used_function_names.add(function_name_)
    }
  ;

throwz returns [throwz_]
  : ^(THROWS fields_=fields) {
      throwz_ = fields_
    }
  ;

fields returns [fields_]
scope {
  // We gather the fields in this variable in the parent scope.
  field_list;

  // Maps from field identifier to name and vice versa. Used for validation.
  used_field_identifiers;
  used_field_names;
}
@init {
  $fields::field_list = []
  $fields::used_field_identifiers = {}
  $fields::used_field_names = {}
}
@after {
  fields_ = $fields::field_list
}
  : field*
  ;

field
  : ^(FIELD field_identifier_=intConstant field_requiredness_=fieldRequiredness?
        field_type_=fieldType IDENTIFIER field_value_=fieldValue? XSD_OPTIONAL?
        XSD_NILLABLE? xsdAttributes? annotations_=typeAnnotations) {
      field_name_ = $IDENTIFIER.text
      if field_name_ in $fields::used_field_names:
        raise self._error($IDENTIFIER, 'Field name ' + field_name_ + ' for identifier ' +
                                       str(field_identifier_) + ' already used for identifier ' +
                                       str($fields::used_field_names[field_name_]))
      if field_identifier_ in $fields::used_field_identifiers:
        raise self._error($FIELD, 'Field identifier ' + str(field_identifier_) +
                                  ' for ' + field_name_ + ' already used for ' +
                                  $fields::used_field_identifiers[field_identifier_])
      if field_identifier_ <= 0:
        raise self._error($FIELD, 'Field identifier for ' + field_name_ + ' must be >= 1: ' +
                                  str(field_identifier_))

      if field_identifier_ >= 2**15:
        raise self._error($FIELD, 'Field identifier for ' + field_name_ + ' must be < 2^15: ' +
                                  str(field_identifier_))

      field_ = thrift_descriptors.Field()
      field_.identifier = field_identifier_
      field_.name = field_name_
      field_.typeId = field_type_.id
      if field_requiredness_ is not None:
        field_.requiredness = field_requiredness_
      if field_value_ is not None:
        field_.defaultValue = field_value_
      if annotations_ is not None:
        field_.annotations = annotations_
      $fields::field_list.append(field_)
      $fields::used_field_identifiers[field_identifier_] = field_name_
      $fields::used_field_names[field_name_] = field_identifier_
    }
  ;

fieldRequiredness returns [field_requiredness_]
  : REQUIRED { field_requiredness_ = thrift_descriptors.Requiredness.REQUIRED }
  | OPTIONAL { field_requiredness_ = thrift_descriptors.Requiredness.OPTIONAL }
  ;

functionType returns [function_type_]
  : VOID { function_type_ = None }
  | field_type_=fieldType { function_type_ = field_type_ }
  ;

fieldType returns [field_type_]
scope {
  // We capture the active union element in the parent scope.
  simple_type_;
}
@init {
  $fieldType::simple_type_ = thrift_descriptors.SimpleType()
}
@after {
  field_type_ = thrift_descriptors.Type()
  field_type_.simpleType = $fieldType::simple_type_
  self._registerType($fieldType, field_type_)
}
  : IDENTIFIER {
      typeref_ = thrift_descriptors.Typeref()
      typeref_.typeAlias = $IDENTIFIER.text
      $fieldType::simple_type_.typeref = typeref_
    }
  | baseType
  | containerType
  ;

baseType
  : simple_base_type_=simpleBaseType annotations_=typeAnnotations {
      base_type_ = thrift_descriptors.BaseType()
      base_type_.simpleBaseType = simple_base_type_
      if annotations_ is not None:
        base_type_.annotations = annotations_
      $fieldType::simple_type_.baseType = base_type_
    }
  ;

simpleBaseType returns [simple_base_type_]
  : STRING { simple_base_type_ = thrift_descriptors.SimpleBaseType.STRING; }
  | BINARY { simple_base_type_ = thrift_descriptors.SimpleBaseType.BINARY; }
  | BOOL   { simple_base_type_ = thrift_descriptors.SimpleBaseType.BOOL;   }
  | BYTE   { simple_base_type_ = thrift_descriptors.SimpleBaseType.BYTE;   }
  | I16    { simple_base_type_ = thrift_descriptors.SimpleBaseType.I16;    }
  | I32    { simple_base_type_ = thrift_descriptors.SimpleBaseType.I32;    }
  | I64    { simple_base_type_ = thrift_descriptors.SimpleBaseType.I64;    }
  | DOUBLE { simple_base_type_ = thrift_descriptors.SimpleBaseType.DOUBLE; }
  ;

containerType
  : simple_container_type_=simpleContainerType annotations_=typeAnnotations {
      container_type_ = thrift_descriptors.ContainerType()
      container_type_.simpleContainerType = simple_container_type_
      if annotations_ is not None:
        container_type_.annotations = annotations_
      $fieldType::simple_type_.containerType = container_type_
    }
  ;

simpleContainerType returns [simple_container_type_]
// We capture the active union element here.
@init {
  simple_container_type_ = thrift_descriptors.SimpleContainerType()
}
  :
  ^(MAP cppType? key_type_=fieldType value_type_=fieldType) {
    map_type_ = thrift_descriptors.MapType()
    map_type_.keyTypeId = key_type_.id
    map_type_.valueTypeId = value_type_.id
    simple_container_type_.mapType = map_type_
  }
  |
  ^(SET cppType? entry_type_=fieldType) {
    set_type_ = thrift_descriptors.SetType()
    set_type_.elementTypeId = entry_type_.id
    simple_container_type_.setType = set_type_
  }
  |
  ^(LIST cppType? entry_type_=fieldType) {
    list_type_ = thrift_descriptors.ListType()
    list_type_.elementTypeId = entry_type_.id
    simple_container_type_.listType = list_type_
  };

cppType: ^(CPP_TYPE LITERAL);

fieldValue returns [field_value_]:
  DEFAULT cv_=constValue { field_value_ = $cv_.text };

typeAnnotations returns [annotations_]
scope {
  // We gather the annotations in this variable in the parent scope.
  annotations_list;
}
@init {
  $typeAnnotations::annotations_list = []
}
@after {
  annotations_ = $typeAnnotations::annotations_list
}
  : typeAnnotation*
  ;

typeAnnotation
  :
  ^(TYPE_ANNOTATION key_=IDENTIFIER value_=LITERAL) {
    annotation_ = thrift_descriptors.Annotation($key_.text, $value_.text[1:-1])
    $typeAnnotations::annotations_list.append(annotation_)
  }
  ;

xsdAttributes: ^(XSD_ATTRIBUTES fields);

intConstant returns [i]
  : INTCONSTANT { i = int($INTCONSTANT.text, 10) }
  | HEXCONSTANT { i = int($HEXCONSTANT.text, 16) }
  ;
